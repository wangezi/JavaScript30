<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>JS Reference VS Copy</title>
  <link rel="icon" href="https://fav.farm/ğŸ¼" />
</head>

<body>

  <script>
    // start with strings, numbers and booleans (å¾å­—ä¸²ã€æ•¸å­—å’Œå¸ƒæ—å€¼é–‹å§‹)
    // let num = 100;
    // let num2 = num;
    // console.log(num, num2);

    // num = 200;
    // console.log(num, num2);

    // let name = 'Ian';
    // let name2 = name;
    // console.log(name, name2);
    // name = 'IanYin';
    // console.log(name, name2);

    // Let's say we have an array (å‡è¨­æˆ‘å€‘æœ‰ä¸€å€‹æ•¸çµ„)
    const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

    // and we want to make a copy of it. (æˆ‘å€‘æƒ³è¦è¤‡è£½å®ƒã€‚)

    const team = players;

    console.log(players, team);

    // You might think we can just do something like this: (ä½ å¯èƒ½æœƒèªç‚ºæˆ‘å€‘å¯ä»¥é€™æ¨£åšï¼š)

    // team[3] = 'Lux';
    // console.log(team);

    // however what happens when we update that array? (ä½†æ˜¯ç•¶æˆ‘å€‘æ›´æ–°è©²æ•¸çµ„æ™‚æœƒç™¼ç”Ÿä»€éº¼ï¼Ÿ)

    // now here is the problem! (ç¾åœ¨é€™æ˜¯å•é¡Œï¼)

    // oh no - we have edited the original array too! (å“¦ä¸-æˆ‘å€‘ä¹Ÿç·¨è¼¯äº†åŸå§‹æ•¸çµ„ï¼)

    // Why? It's because that is an array reference, not an array copy. They both point to the same array! (ç‚ºä»€éº¼ï¼Ÿå› ç‚ºé‚£æ˜¯ä¸€å€‹æ•¸çµ„å¼•ç”¨ï¼Œè€Œä¸æ˜¯ä¸€å€‹æ•¸çµ„å‰¯æœ¬ã€‚å®ƒå€‘éƒ½æŒ‡å‘åŒä¸€å€‹æ•¸çµ„ï¼)

    // So, how do we fix this? We take a copy instead! (é‚£éº¼ï¼Œæˆ‘å€‘è©²å¦‚ä½•è§£æ±ºé€™å€‹å•é¡Œï¼Ÿæˆ‘å€‘å–ä¸€å€‹å‰¯æœ¬ï¼)

    const team2 = players.slice();
    const team3 = [].concat(players);

    // one way (ä¸€ç¨®æ–¹æ³•)
    const team4 = [...players];
    team4[3] = 'hello';
    console.log(team4);

    const team5 = Array.from(players);

    // or create a new array and concat the old one in (æˆ–è€…å‰µå»ºä¸€å€‹æ–°æ•¸çµ„ï¼Œç„¶å¾Œé€£æ¥èˆŠæ•¸çµ„)

    // or use the new ES6 Spread (æˆ–ä½¿ç”¨æ–°çš„ES6 Spread)

    // now when we update it, the original one isn't changed (ç¾åœ¨ç•¶æˆ‘å€‘æ›´æ–°å®ƒæ™‚ï¼ŒåŸå§‹æ•¸çµ„ä¸æœƒæ”¹è®Š)

    // The same thing goes for objects, let's say we have a person object (å°æ–¼å°è±¡ä¹Ÿæ˜¯ä¸€æ¨£çš„ï¼Œå‡è¨­æˆ‘å€‘æœ‰ä¸€å€‹äººå°è±¡)

    // with Objects (å°è±¡)
    const person = {
      name: 'Wes Bos',
      age: 80
    };

    // and think we make a copy:  (ä¸¦ä¸”èªç‚ºæˆ‘å€‘åšäº†ä¸€ä»½å‰¯æœ¬ï¼š)

    // const captain = person;
    // captain.number = 99;
    // console.log(captain)

    // how do we take a copy instead? (æˆ‘å€‘è©²å¦‚ä½•å–ä»£ä¸€ä»½å‰¯æœ¬ï¼Ÿ)

    const captain2 = Object.assign({}, person, { number: 99, age: 12 });
    console.log(captain2);

    // We will hopefully soon see the object ...spread  (æˆ‘å€‘å¾ˆå¿«å°±æœƒçœ‹åˆ°å°è±¡...spread)

    // const captain3 = { ...person };

    // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it. (éœ€è¦æ³¨æ„çš„æ˜¯-é€™åªæœ‰1ç´šæ·±åº¦-å°æ–¼æ•¸çµ„å’Œå°è±¡éƒ½æ˜¯å¦‚æ­¤ã€‚lodashæœ‰ä¸€å€‹cloneDeepæ–¹æ³•ï¼Œä½†åœ¨ä½¿ç”¨å®ƒä¹‹å‰ï¼Œæ‚¨æ‡‰è©²ä¸‰æ€ã€‚)

    const ian = {
      name: 'Ian',
      age: 18,
      social: {
        IG: 'zhong_yin',
        Line: 'Eã„—'
      }
    };

    console.clear();
    console.log(ian);

    const dev = Object.assign({}, wes);

    const dev2 = JSON.parse(JSON.stringify(wes));

  </script>

</body>

</html>